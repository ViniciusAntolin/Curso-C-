/* MASTER */
--TODAS AS INFORMAÇÕES CRIADAS NO SQL SERVER SÃO ARMAZENADAS NO BANCO MASTER. NOMES, DONOS, TABELAS.

/* MODEL */
--Tudo que for criado no banco de dados model, quando você criar um novo banco, será com base nas presentes no model.

/* MSDB */
-- Serviços de agendamento, agendamento de rotinas, horas da execução, dono da execução, intervalos, todos são armazenados no msdb.
-- o que é feito no integration service, são armazenados no msdb

/* TEMPDB */
-- São armazenadas tabelas temporárias para consultas e afins.

/* ReportServer$SQLEXPRESS */
-- Fica armazenado os relatórios para serem mostrados aos clientes.

/* ReportServer$SQLEXPRESSTempDB */
-- Quando o de cima está muito cheio ele faz o balanceamento, mandando alguns relattórios para este banco.

/* A Claúsula GO */

/* Assunto - delimitador */
/* CTRL + R para sumir a aba dos resultados que reaparecem quando executa */

CREATE DATABASE AULA_SQL

USE AULA_SQL

CREATE TABLE TESTE(
	NOME VARCHAR(30)

)

--ASSÍNCRONO
-- CLIENTE
-- 1 2 3 --> SERVER
-- FAZ O MAIS FÁCIL PRIMEIRO, DEPOIS O MAIS DIFÍCIL E PARA RESOLVER BASTA USAR O (GO)
-- O GO QUEBRA OS COMANDO INSERIDOS NO CLIENTES EM PACOTES PARA MANDAR PARA O SERVIDOR

CREATE DATABASE AULA_SQL2
GO

USE AULA_SQL2
GO

CREATE TABLE TESTE(
	NOME VARCHAR(30)

)
GO

/* ARQUIVO LDF E MDF */
-- UMA BOA PRATICA É SEPARAR OS PROGRAMS EM PARTES.
-- COLOCAR O WINDOWS NO (C), O SQL SERVER NO (D) E OS BANCOS NO (E)

/* MDF */
-- Master Data File
-- Armazena os dados inseridos
-- Deixar apenas os dados do sistema. (DICIONARIO)

/* LDF */
--Lod Data File
-- Armazena logs
-- Enquanto estou inserindo dados, é feita uma transação que é inserida no LDF e caso eu faça um commit ele salva o MDF caso faça rollback, ele apaga do LDF. usando begin tran, commit ou rollback.

/* NDF */
-- Not Master Data File


/* GRUPOS */
-- Separo os arquivos ndf em grupos e apontar as tabelas para um grupo
-- Possibilita uma flexibilidade grande e você pode fazer a análise dos espaços e usos.
-- Todo banco tem um grupo padrão chamado primary e ele não deixas de ser criado e o arquivo MDF sempre vai dentro dele.

/* Organizar fisicamente e logicamente um banco de dados

1- Criar o banco com arquivos para os setores de mkt e Vendas

2- Criar um arquivo geral

3- Deixar o MDF apenas com o dicionario de dados

4- Criar 2 grupos de arquivos (PRIMARY - MDF)
 */
-- Você póde criar um grupo de arquivos para ser o que irá receber como default os arquivos.

-- Pode ser feita a criação de tabelas e especificar para onde ela irá.
-- Pode também falar para onde os filestream (TEXTO/ IMAGEM )irão.
-- Quando são criados os grupos é necessário especificar os arquivos deles e o nome do arquivo como o nome lógico e a extenção de .NDF

/* 101. Constraints Nomeadas, Identity, SP_COLUMNS e SP_HELP */  

/* CONECTANDO A UM BANCO */
USE EMPRESA 
GO

/* CRIANDO TABELAS */
-- O Padrão do Identity é (1,1) começa com 1 e incrementa de 1 em 1.
CREATE TABLE ALUNO(
	IDALUNO INT PRIMARY KEY Identity,
	NOME VARCHAR(30) NOT NULL,
	SEXO CHAR(1) NOT NULL,
	NASCIMENTO DATE NOT NULL,
	EMAIL VARCHAR(30) UNIQUE
)
GO

/* CRIANDO CONSTRAINTS */
-- CHECK CHECA SE O QUE ESTÁ ENTRANDO É O QUE FOI INFORMADO POR NÓS.
ALTER TABLE ALUNO
ADD CONSTRAINTS CK_SEXO 
CHECK (SEXO IN('M', 'F'))
GO

/* 1 x 1 */
CREATE TABLE ENDERECO(
	ID ENDERECO INT PRIMARY KEY Identity(100,10),
	BAIRRO VARCHAR(30),
	UF CHAR(2) NOT NULL
	CHECK (UF IN('RJ', 'SP', 'MG')),
	ID_ALUNO INT UNIQUE
)
GO

ALTER TABLE ENDERECO
ADD CONSTRAINT FK_ENDERECO_ALUNO
FOREIGN KEY (ID_ALUNO) REFERENCES ALUNO(IDALUNO)
GO
/* COMANDOS DE DESCRICAO */
/* FEITO POR PROCEDURES - JA CRIADAS E ARMAZENAS NO SISTEMA */
/* TODA PROCEDURE COMEÇA COM SP, POIS REMETE A STORAGE_PROCEDURE */

-- MOSTRA AS INFORMAÇÕES DAS COLUNAS
SP_COLUMNS ALUNO
GO

--MOSTRA TODAS AS INFORMAÇÕES DA TABELA E COLUNAS.
SP_HELP ALUNO
GO

/* Tudo que tem o parentese é uma função */
GETDATE()

/* JOIN É COM A CLAUSULA ON, SE COLCOAR WHERE ELE APLICA A */

/* Não utlizar * */

 /* 103. Trabalhando com Datas */

/* DATEDIFF - CALCULA A DIFERENÇA ENTRE 2 DATAS */
SELECT NOME, DATEDIFF(YEAR, NASCIMENTO, GETDATE()) AS DIA_HORA 
FROM ALUNO

/* DATENAME - TRAZ O NOME DA PARTE DA DATA EM QUESTÃO */
SELECT NOME, DATENAME(MONTH, NASCIMENTO)
FROM ALUNO

SELECT NOME, DATENAME(WEEKDAY, NASCIMENTO)
FROM ALUNO

SELECT NOME, DATENAME(YEAR, NASCIMENTO)
FROM ALUNO

/* DATENAME - MESMA COISA, PORÉM O RETORNO É INTEIRO*/
SELECT NOME, DATEPART(MONTH, NASCIMENTO)
FROM ALUNO

SELECT NOME, DATEPART(WEEKDAY, NASCIMENTO)
FROM ALUNO

SELECT NOME, DATEPART(YEAR, NASCIMENTO)
FROM ALUNO

/* DATEADD - RETORNA UMA DATA SOMANDO A OUTRA DATA */

SELECT DATEADD(MONTH, 1, GETDATE())



/* 104. Conversões de tipos de dados */

-- o (+) serve para concatenção e para somar

/* FUNÇÕES DE CONVERSÃO DE DADOS */
SELECT CAST('1' AS INT) + CAST('1' AS INT)

/* conversão e concatenção */

select nome,
DAY(NASCIMENTO) + '/' + MONTH(NASCIMENTO) + '/' YEAR(NASCIMENTO)
FROM ALUNO
GO

select nome,
CAST(DAY(NASCIMENTO) as VARCHAR(MAX)) + '/' + CAST(MONTH(NASCIMENTO) as VARCHAR(MAX)) + '/' CAST(YEAR(NASCIMENTO) as VARCHAR(MAX))
FROM ALUNO
GO

/* CHARINDEX - RETORNA UM INTEIRO EM UMA COLUNA 
CONTAGEM DEFAULT - INCIA EM 01
MOSTRA A POSIÇÃO EM QUE UM CARACTER ESTÁ COMO MOSTRADO NO SELECT ABAIXO
*/

CHARINDEX(OQUE?, ONDE?, A PARTI DE) RETORNA INT

SELECT NOME, CHARINDEX('A', NOME) AS INDICE
FROM ALUNO

SELECT NOME, CHARINDEX('A', NOME, 2) AS INDICE
FROM ALUNO

-- QUANDO DEFINO A POSIÇÃO EM QUE IRÁ COMEÇAR, ELE DESCONSIDERA NA PROCURA, POR EXEMPLO ANA, O RETORNO SERIA 1, PORÉM COMEÇANDO DO 2, ELE RETORNARIA 3, POIS DESONCIDEROU APENAS A SELEÇÃO E NÃO A POSIÇÃO

/* 107. Utilizando Bulk Insert - Desafio utilizando CHARINDEX */

/* BULK INSERT - IMPORTAÇÃO DE ARQUIVOS */

CREATE TABLE LANCAMENTO_CONTABIL(
	CONTA INT,
	VALOR INT,
	DEB_CRED CHAR(1)

)
GO

SELECT * FROM LANCAMENTO_CONTABIL
GRUPOS

-- \t = TAB

BULK INSERT LANCAMENTO_CONTABIL
FROM 'c:\arquivos\contas.txt'
WITH
(
	FIRSTROW = 2,
	DATAFILETYPE = 'CHAR'
	FIELDTERMINATOR = '\t' -- \t = TAB
	ROWTERMINATOR = '\n' -- \N = ENTER
)
-- SE TIVER ENTER ELE IRÁ INSERIR COMO NULL

/* DESAFIO DO SALDO QUERY QUE TRAGA O NUMERO DA CONTA SALDO - DEVEDOR OU CREDOR */

SELECT CONTA, VALOR, 
CHARINDEX('D', DEB_CRED) AS DEBITO,
CHARINDEX('C', DEB_CRED) AS CREDITO
FROM LANCAMENTO_CONTABIL

SELECT CONTA, VALOR, 
CHARINDEX('D', DEB_CRED) AS DEBITO,
CHARINDEX('C', DEB_CRED) AS CREDITO,
CHARINDEX('C', DEB_CRED) * 2 - 1 AS MULTIPLICADOR
FROM LANCAMENTO_CONTABIL


SELECT CONTA, 
SUM(VALOR * (CHARINDEX('C', DEB_CRED) * 2 - 1)) AS SALDO
FROM LANCAMENTO_CONTABIL
GROUP BY CONTA

/* FLEGAMOS A COLUNA, PARA IDENTIFICAR O QUE É CREDITO OU DEBITO E COM ISSO, MULTIPLICAR O VALOR * O RESULTADO */

/* 109. Triggers de DML */

CREATE TABLE PRODUTOS(
	IDPRODUTO INT Identity PRIMARY KEY,
	NOME VARCHAR(50) NOT NULL,
	CATEGORIA VARCHAR(30) NOT NULL,
	PRECO NUMERIC(10,2) NOT NULL

)
GO

CREATE TABLE HISTORICO(
	IDOPERACAO INT PRIMARY KEY Identity,
	NOME VARCHAR(50) NOT NULL,
	CATEGORIA VARCHAR(30) NOT NULL,
	PRECOANTIGO NUMERIC(10,2) NOT NULL,
	PRECONOVO NUMERIC(10,2) NOT NULL,
	DATA DATETIME,
	USUARIO VARCHAR(30),
	MENSAGEM VARCHAR(100)
)
go

INSERT INTO PRODUTOS VALUES('LIVRO SQL SERVER', 'LIVROS', 98.00)
INSERT INTO PRODUTOS VALUES('LIVRO ORACLE', 'LIVROS', 50.00)
INSERT INTO PRODUTOS VALUES('LICENÇA POWERCENTER', 'SOFTWARE', 45000.00)
INSERT INTO PRODUTOS VALUES('NOTEBOOK 17', 'COMPUTADORES', 3150.00)
INSERT INTO PRODUTOS VALUES('LIVRO BUSINNES INTELLIGENCE', 'LIVROS', 45000.00)
GO

SELECT * FROM PRODUTOS
SELECT * FROM HISTORICO

/* VERIFICANDO O USUARIO */

SELECT SUSER_NAME()
GO

/* TRIGGER DE DADOS - DATA MANIPULATION LANGUAGE */

/* DBO É UM SCHEMA - SCHEMA É UM DIVISOR LOGICO DE BANCO DE DADOS 

QUANDO É DEFINIDO DBO. É POR NÃO TER UM DONO, SE VOCÊ CRIA OS FILEGROUPS, PODEMOS DIZER O DONO DE ALGUM DOS GRUPOS É MARKETING, 
POIS ESTÁ DENTRO DO BANCO, PORÉM QUEM GERENCIA É O FILEGROUP MKT, ALGO NESSE SENTIDO, PROCURAR MAIS A RESPEITO.
*/

CREATE TRIGGER TRG_ATUALIZA_PRECO
ON DBO.PRODUTOS
FOR UPDATE --QUANDO DESPARAR: QUANDO FIZER UPDATE
AS 
		DECLARE @IDPRODUTO INT , 
		@NOME VARCHAR(30), 
		@CATEGORIA VARCHAR(10),
		@PRECOANTIGO NUMERIC(10,2),
		@PRECONOVO NUMERIC(10,2) ,
		@DATA DATETIME,
		@USUARIO VARCHAR(30),
		@MENSAGEM VARCHAR(100)

/* O SQL SERVER TEM DUAS ÁREAS INSERTED | DELETED, SE EU PROCURAR ALGO FOR DELETADO, VAI PARA A DELETED E SE INSERIR, VAI PARA A INSERTED - 
ISSO É TRANSPARENTE NÃO VEMOS 

UPDATE É PROCURADO NAS DUAS ÁREAS.
INSERTED | DELETED
*/
		--PRIMEIRO BLOCO
		/* VALORES VINDOS DE TABELAS SÃO INSERIDOS COM O COMANDO SELECT */
		SELECT @IDPRODUTO = IDPRODUTO ,
		@NOME = NOME,
		@CATEGORIA = CATEGORIA,
		@PRECONOVO = PRECO
		FROM inserted

		SELECT @PRECOANTIGO = PRECO FROM deleted

		--PRIMEIRO BLOCO
		/* VALORES VINDOS DE FUNÇÕES OU VALORES LITERAIS DEVEM SER ATRIBUIDOS COM O COMANDO SET*/
		SET	@DATA = GETDATE	()
		SET	@USUARIO = SUSER_NAME() --VALOR VINDO DE FUNÇÃO ()
		SET	@MENSAGEM = 'VALOR INSERIDO PELA TRIGGER TRG_ATUALIZA_PRECO' -- VALOR LITERAL

		INSERT INTO HISTORICO
		(NOME, CATEGORIA, PRECOANTIGO, PRECONOVO, DATA, USUARIO, MENSAGEM)
		VALUES
		(@NOME, @CATEGORIA, @PRECOANTIGO, @PRECONOVO, @DATA, @USUARIO, @MENSAGEM)

		PRINT 'TRIGGER EXECUTADA COM SUCESSO'
GO

/* EXECUTANDO UM UPDATE */

UPDATE PRODUTOS 
SET PRECO = 100.00 
WHERE IDPRODUTO = 1
GO

SELECT * FROM PRODUTOS
SELECT * FROM HISTORICO

UPDATE PRODUTOS 
SET NOME = 'LIVRO C#'
WHERE IDPRODUTO = 1
GO

SELECT * FROM PRODUTOS
SELECT * FROM HISTORICO

/* PROGRAMANDO TRIGGER EM UMA COLUNA */

DROP TRIGGER TRG_ATUALIZA_PRECO
GO

CREATE TRIGGER TRG_ATUALIZA_PRECO
ON DBO.PRODUTOS
FOR UPDATE --QUANDO DESPARAR: QUANDO FIZER UPDATE
AS 
IF UPDATE(PRECO) -- LINGUAGEM TSQL - TRANSACTIONAL SQL LANGUAGE
BEGIN			-- SEMPRE INICIARÁ EM BEGIN
		DECLARE @IDPRODUTO INT , 
		@NOME VARCHAR(30), 
		@CATEGORIA VARCHAR(10),
		@PRECOANTIGO NUMERIC(10,2),
		@PRECONOVO NUMERIC(10,2) ,
		@DATA DATETIME,
		@USUARIO VARCHAR(30),
		@MENSAGEM VARCHAR(100)

/* O SQL SERVER TEM DUAS ÁREAS INSERTED | DELETED, SE EU PROCURAR ALGO FOR DELETADO, VAI PARA A DELETED E SE INSERIR, VAI PARA A INSERTED - 
ISSO É TRANSPARENTE NÃO VEMOS 

UPDATE É PROCURADO NAS DUAS ÁREAS.
INSERTED | DELETED
*/
		--PRIMEIRO BLOCO
		/* VALORES VINDOS DE TABELAS SÃO INSERIDOS COM O COMANDO SELECT */
		SELECT @IDPRODUTO = IDPRODUTO ,
		@NOME = NOME,
		@CATEGORIA = CATEGORIA,
		@PRECONOVO = PRECO
		FROM inserted

		SELECT @PRECOANTIGO = PRECO FROM deleted

		--PRIMEIRO BLOCO
		/* VALORES VINDOS DE FUNÇÕES OU VALORES LITERAIS DEVEM SER ATRIBUIDOS COM O COMANDO SET*/
		SET	@DATA = GETDATE	()
		SET	@USUARIO = SUSER_NAME() --VALOR VINDO DE FUNÇÃO ()
		SET	@MENSAGEM = 'VALOR INSERIDO PELA TRIGGER TRG_ATUALIZA_PRECO' -- VALOR LITERAL

		INSERT INTO HISTORICO
		(NOME, CATEGORIA, PRECOANTIGO, PRECONOVO, DATA, USUARIO, MENSAGEM)
		VALUES
		(@NOME, @CATEGORIA, @PRECOANTIGO, @PRECONOVO, @DATA, @USUARIO, @MENSAGEM)

		PRINT 'TRIGGER EXECUTADA COM SUCESSO'
END
GO



UPDATE PRODUTOS 
SET PRECO = 200.00 
WHERE IDPRODUTO = 2
GO

SELECT * FROM PRODUTOS
SELECT * FROM HISTORICO

UPDATE PRODUTOS 
SET NOME = 'LIVRO SQL SERVER'
WHERE IDPRODUTO = 1
GO

SELECT * FROM PRODUTOS
SELECT * FROM HISTORICO

UPDATE PRODUTOS 
SET NOME = 'LIVRO ORACLE TOP'
WHERE IDPRODUTO = 2
GO

/* VARIAVEIS COM SELECT */

CREATE TABLE RESULTADO(
	IDRESULTADO INT PRIMARY KEY IDENTITY,
	RESULTADO INT
)
GO

INSERT INTO RESULTADO VALUES ((SELECT 10+10))

SELECT * FROM RESULTADO

/* ATRIBUINDO SELECT A VARIAVEIS - ANONIMO */

DECLARE @RESULTADO INT
	SET @RESULTADO = (SELECT 30+50)

INSERT INTO RESULTADO VALUES (@RESULTADO)

PRINT 'VALOR INSERIDO NA TABELA: ' + CAST(@RESULTADO AS VARCHAR(MAX))
GO

/* TRIGGER UPDATE */

CREATE TABLE EMPREGADO(
	IDEMPREGADO INT PRIMARY KEY IDENTITY,
	NOME VARCHAR(30),
	SALARIO MONEY, -- A DIFERENÇA ENTRE NUMERIC E MONEY É QUE MONEY JÁ VEM POR PADRÃO COM .00,
	--ENQUANTO O NUMERIC NÃO
	IDGERENTE INT
)
GO 

ALTER TABLE EMPREGADO 
ADD CONSTRAINT FK_GERENTE
FOREIGN KEY (IDGERENTE) 
REFERENCES EMPREGADO(IDEMPREGADO)
GO

INSERT INTO EMPREGADO VALUES('EDUARDO', 5000.00, NULL)
INSERT INTO EMPREGADO VALUES('JOAO', 4000.00, 1)
INSERT INTO EMPREGADO VALUES('IEDA', 4000.00, 1)
INSERT INTO EMPREGADO VALUES('CAMILA', 6000.00, 1)
INSERT INTO EMPREGADO VALUES('CLAUDIA', 4000.00, 1)
GO

SELECT * FROM EMPREGADO

CREATE TABLE HIST_SALARIO(
	IDHIST INT PRIMARY KEY IDENTITY,
	IDEMPREGADO INT,
	SALARIO_NOVO MONEY,
	SALARIO_ANTIGO MONEY,
	DATA DATETIME
)
GO 

CREATE TRIGGER TRG_SALARIO
ON DBO.EMPREGADO
FOR UPDATE AS
IF UPDATE(SALARIO)
BEGIN

	INSERT INTO HIST_SALARIO
	(IDEMPREGADO, SALARIO_ANTIGO, SALARIO_NOVO, DATA)
	SELECT D.IDEMPREGADO, D.SALARIO, I.SALARIO ,GETDATE()
	FROM deleted D, inserted I
	WHERE D.IDEMPREGADO = I.IDEMPREGADO -- ONDE AS DUAS FOREM IGUAIS IRÁ INSERIR NA TABELA

END
GO

SELECT * FROM EMPREGADO
SELECT * FROM HIST_SALARIO

UPDATE EMPREGADO SET SALARIO = SALARIO * 1.1
GO

/* SALARIO NOVO, ANTIGO, DATA, NOME */

ALTER TABLE HIST_SALARIO
ADD NOME VARCHAR(MAX)

ALTER TRIGGER TRG_SALARIO
ON DBO.EMPREGADO
FOR UPDATE AS
IF UPDATE(SALARIO)
BEGIN

	INSERT INTO HIST_SALARIO
	(IDEMPREGADO, SALARIO_ANTIGO, SALARIO_NOVO, DATA, NOME)
	SELECT D.IDEMPREGADO, D.SALARIO, I.SALARIO ,GETDATE(), D.NOME
	FROM deleted D, inserted I
	WHERE D.IDEMPREGADO = I.IDEMPREGADO -- ONDE AS DUAS FOREM IGUAIS IRÁ INSERIR NA TABELA

END
GO

UPDATE EMPREGADO SET SALARIO = SALARIO * -1.1
GO

SELECT * FROM EMPREGADO
SELECT * FROM HIST_SALARIO


/* SALARIO NOVO, ANTIGO, DATA, NOME */

CREATE TABLE SALARIO_RANGE (
	SALARIO_MINIMO MONEY,
	SALARIO_MAXIMO MONEY
)
GO

INSERT INTO SALARIO_RANGE VALUES(3000.00, 6000.00)
GO

CREATE TRIGGER TG_RANGE
ON DBO.EMPREGADO
FOR INSERT, UPDATE
AS 
	DECLARE
		@SALARIO_MINIMO MONEY,
		@SALARIO_MAXIMO MONEY,
		@SALARIO_ATUAL MONEY

	SELECT @SALARIO_MINIMO = SALARIO_MINIMO,
	@SALARIO_MAXIMO = SALARIO_MAXIMO
	FROM SALARIO_RANGE

	SELECT @SALARIO_ATUAL = I.SALARIO FROM inserted I
	
	IF @SALARIO_ATUAL < @SALARIO_MINIMO
	BEGIN
			RAISERROR('SALARIO MENOR QUE O PISO', 16,1)
			ROLLBACK TRANSACTION

	END

	IF @SALARIO_ATUAL > @SALARIO_MAXIMO
	BEGIN
			RAISERROR('SALARIO MAIOR QUE O TETO', 16,1)
			ROLLBACK TRANSACTION

	END
GO

UPDATE EMPREGADO SET SALARIO = SALARIO * 1.1
GO

SELECT * FROM EMPREGADO
GO
/* Temos arquivos de LOG e arquivos de dados.
Tudo que fazemos, primeiro ele é feito no LOG só é passado para os dados (MDF/NDF) quando
confirmado.

O procedimento de dar rollback, elimina do LOG, portanto não insere no arquivod e dados
*/

/* Verificando o texto de uma TRIGGER */

SP_HELPTEXT TG_RANGE -- TRANSFORMA EM TEXTO PARA NÃO TER QUE GERAR TUDO NOVAMENTE.
GO

/* PROCEDURES */

--SP_ STORAGE PROCEDURE

CREATE TABLE PESSOA(
	IDPESSOA INT PRIMARY KEY IDENTITY,
	NOME VARCHAR(30) NOT NULL,
	SEXO CHAR(1) NOT NULL CHECK (SEXO IN('M','F')), --ENUM
	MASCIMENTO DATE NOT NULL
)
GO

CREATE TABLE TELEFONE(
	IDTELEFONE INT NOT NULL IDENTITY,
	TIPO CHAR(3) NOT NULL CHECK ( TIPO IN('CEL','COM')),
	NUMERO CHAR(10) NOT NULL,
	ID_PESSOA INT
)
GO

ALTER TABLE TELEFONE ADD CONSTRAINT FK_TELEFONE_PESSOA
FOREIGN KEY(ID_PESSOA) REFERENCES PESSOA(IDPESSOA)
ON DELETE CASCADE
GO

INSERT INTO PESSOA VALUES('ANTONIO','M','1981-02-13')
INSERT INTO PESSOA VALUES('DANIEL','M','1985-03-18')
INSERT INTO PESSOA VALUES('CLEIDE','F','1979-10-13')
INSERT INTO PESSOA VALUES('MAFRA','M','1981-02-13')
GO

INSERT INTO TELEFONE VALUES('CEL','9879008',1)
INSERT INTO TELEFONE VALUES('COM','8757909',1)
INSERT INTO TELEFONE VALUES('CEL','9875890',2)
INSERT INTO TELEFONE VALUES('CEL','9347689',2)
INSERT INTO TELEFONE VALUES('COM','2998689',3)
INSERT INTO TELEFONE VALUES('COM','2098978',2)
INSERT INTO TELEFONE VALUES('CEL','9008679',3)
GO

/* CRIANDO A PROCEDURE */

CREATE PROC SOMA
AS
	SELECT 10+10 AS SOMA
GO

/* EXECUÇÃO DA PROCEDURE */

EXEC SOMA
GO

/* DINAMICAS - COM PARÂMETROS */
CREATE PROC CONTA @NUM1 INT, @NUM2 INT
AS 
	SELECT @NUM1 + @NUM2 AS RESULTADO
	-- UMA ARROBA SÃO VARIÁVEIS INTERNAS, DUAS ARROBAS, SÃO VARIÁVEIS GLOBAIS
GO

EXEC CONTA 1, 2
GO

/* APAGANDO A PROCEDORE */
DROP PROC CONTA
GO

/* PROCEDURES EM TABELAS */

SELECT NOME, NUMERO
FROM PESSOA P
INNER JOIN TELEFONE T
ON P.IDPESSOA = T.ID_PESSOA
WHERE TIPO = 'CEL'
GO

/* TRAZER OS TELEFONES DE ACORDO COM O TIPO PASSADO POR PARAMETROS */
CREATE PROC TELEFONES @TIPO CHAR(3)
AS 
	SELECT NOME, NUMERO
	FROM PESSOA P
	INNER JOIN TELEFONE T
	ON P.IDPESSOA = T.ID_PESSOA
	WHERE TIPO = @TIPO
GO

EXEC TELEFONES 'CEL'
GO

EXEC TELEFONES 'COM'
GO

/* PARAMETROS DE OUTPUT */

/* PROCEDURE PEDE PARAMETRO @ DE ENTRADA INPUT
MAS TAMBÉM PODE SAIR OUTPUT */

SELECT TIPO, COUNT(*) AS QUANTIDADE
FROM TELEFONE
GROUP BY TIPO
GO

CREATE PROCEDURE GETTIPO @TIPO CHAR(3), @CONTADOR INT OUTPUT
AS
	SELECT @CONTADOR = COUNT(*) 
	FROM TELEFONE
	WHERE TIPO = @TIPO

GO

/* T-SQL
TRANSACTION SQL -> LINGUAGEM QUE O SQL SERVER TRABALHA */

/* QUANDO EU DECLARO UMA VARÍAVEL É ABERTO UM ESPAÇO NA MEMORIA RAM
QUE IRÁ ALOCAR ESSA VARIÁVEL QUE RECEBERÁ O TIPO QUE PASSAMOS*/

DECLARE @SAIDA INT
EXEC GETTIPO @TIPO = 'CEL', @CONTADOR = @SAIDA OUTPUT
SELECT @SAIDA
GO

DECLARE @SAIDA INT
EXEC GETTIPO 'CEL', @SAIDA OUTPUT -- A GENTE DIZ QUE VAI SAIR ESSE CARA E SEMPRE PRECISAMOS DECLARAR
SELECT @SAIDA
GO

/* PROCEDURE DE CADASTRO */

CREATE PROCEDURE CADASTRO @NOME VARCHAR(30), @SEXO CHAR(1), @MASCIMENTO DATE, 
@TIPO CHAR(3), @NUMERO VARCHAR(30)
AS
	DECLARE @FK INT

	INSERT INTO PESSOA VALUES(@NOME, @SEXO, @MASCIMENTO)

	SET @FK = (SELECT IDPESSOA FROM PESSOA WHERE IDPESSOA = @@IDENTITY) -- GUARDA O ÚLTIMO PK INSERIDO NA SEÇÃO

	INSERT INTO TELEFONE VALUES(@TIPO, @NUMERO, @FK)
GO

EXEC CADASTRO 'VINCIUS PIRES',
'M', '2001-11-14', 'CEL', '997386237'

SELECT P.*, T.* FROM PESSOA P
INNER JOIN TELEFONE T
ON T.ID_PESSOA = P.IDPESSOA

/* TSQL É UM BLOCO DE LINGUAGEM DE PROGRAMAÇÃO.
PROGRAMAS SÃO UNIDADE QUE PODEM SER CHAMADAS DE BLOCOS ANÔNIMOS.
BLOCOS ANÔNIMOS NÃO RECEBEM NOME, POIS NÃO SÃO SALVOS NO BANCO.
CRIAMOS BLOCOS ANONIMOS QUANOD IREMOS EXECUTA-LOS UMA SÓ VEZ OU TESTAR ALGO
*/

/* BLOCO DE EXECUÇÃO */
BEGIN
		PRINT 'PRIMEIRO BLOCO'
END
GO

/* BLOCO DE ATRIBUIÇÃO DE VARIÁVEIS */

DECLARE 
		@CONTADOR INT
BEGIN
	SET @CONTADOR = 5
	PRINT @CONTADOR
END
GO --ESTÁ SEPARANDO EM UMA BATCH PARA EXECUTAR (DELIMITADOR)

/* NO SQL SERVER CADA COLUNA VARIAVEL LOCAL EXPRESSAO E PARAMETRO TEM UM TIPO.
TIPO É UM ATRIBUTO QUE ESPECIFICA O TIPO DE DADOS DE UM ATRIBUTO
*/

DECLARE 
		@V_NUMERO NUMERIC(10,2) = 100.52,
		@V_DATA DATETIME = '2017-02-07'
BEGIN
		PRINT 'VALOR NUMERICO: ' + CAST(@V_NUMERO AS VARCHAR)
		PRINT 'VALOR NUMERICO: ' + CONVERT(VARCHAR, @V_NUMERO)
		PRINT 'VALOR NUMERICO: ' + CAST(@V_DATA AS VARCHAR)
		PRINT 'VALOR NUMERICO: ' + CONVERT(VARCHAR, @V_DATA, 121)
		PRINT 'VALOR NUMERICO: ' + CONVERT(VARCHAR, @V_DATA, 120)
		PRINT 'VALOR NUMERICO: ' + CONVERT(VARCHAR, @V_DATA, 105)
END
GO

/* 116. Atribuindo resultados à variáveis */

/* ATRIBUINDO RESULTADOS A UMA VARIAVEL */

CREATE TABLE CARROS(
	CARRO VARCHAR(20),
	FABRICANTE VARCHAR(30)
)
GO

INSERT INTO CARROS VALUES('KA','FORD')
INSERT INTO CARROS VALUES('FIESTA','FORD')
INSERT INTO CARROS VALUES('PRISMA','FORD')
INSERT INTO CARROS VALUES('CLIO','RENAULT')
INSERT INTO CARROS VALUES('SANDERO','RENAULT')
INSERT INTO CARROS VALUES('CHEVETE','CHEVROLET')
INSERT INTO CARROS VALUES('OMEGA','CHEVROLET')
INSERT INTO CARROS VALUES('PALIO','FIAT')
INSERT INTO CARROS VALUES('DOBLO','FIAT')
INSERT INTO CARROS VALUES('UNO','FIAT')
INSERT INTO CARROS VALUES('GOL','VOLKSWAGEN')
GO

DECLARE
		@V_CONT_FORD INT,
		@V_CONT_FIAT INT,
		@V_CONT_CHEV INT,
		@V_CONT_VOLK INT
BEGIN
		--METODO 1 - O SELECT PRECISA RETORNAR UMA SIMPLES COLUNA E UM SO RESULTADO
		SET @V_CONT_FORD = (SELECT COUNT(*) FROM CARROS WHERE FABRICANTE = 'FORD')
		PRINT 'QUANTIDADE FORD: ' + CAST(@V_CONT_FORD AS VARCHAR)

		--METODO 2
		SELECT @V_CONT_FIAT = COUNT(*) FROM CARROS WHERE FABRICANTE = 'FIAT'
		PRINT 'QUANTIDADE FIAT: ' + CONVERT(VARCHAR, @V_CONT_FORD)

		--METODO 1
		SET @V_CONT_CHEV = (SELECT COUNT(*) FROM CARROS WHERE FABRICANTE = 'CHEVROLET')
		PRINT 'QUANTIDADE CHEVROLET: ' + CAST(@V_CONT_CHEV AS VARCHAR)

		--METODO 2
		SELECT @V_CONT_VOLK = COUNT(*) FROM CARROS WHERE FABRICANTE = 'VOLKSWAGEN'
		PRINT 'QUANTIDADE VOLKSWAGEN: ' + CONVERT(VARCHAR, @V_CONT_VOLK)
END
GO

/* 117. Trabalhando com estruturas condicionais - IF ELSE */

/* BLOCOS IF E ELSE
BLOCO NOMEADO - PROCEUDRES
*/
DECLARE
		@NUMERO INT = 5
BEGIN --COMEÇO DO BLOCO TSQL
		IF @NUMERO = 5 -- EXPRESSAO BOOLEANA - TRUE
			PRINT 'O VALOR É VERDADEIRO'
		ELSE
			PRINT 'O VALOR É FALSO'
END --FIM DO BLOCO TSQL
GO

/* CASE - O CASE REPRESENTA UMA COLUNA */

DECLARE 
		@CONTADOR INT
BEGIN
		SELECT CASE 
				WHEN FABRICANTE = 'FIAT' THEN 'FAIXA 1'
				WHEN FABRICANTE = 'CHEVROLET' THEN 'FAIXA 2'
				ELSE 'OUTRAS FAIXAS'
			   END AS "INFORMAÇÕES",
			   *
			   FROM CARROS
END
GO

/* CRIANDO BLOCO NOMEADO (PROCEDURES) PARA VERIFICAR SE O VALOR RECEBIDO É 5 */

CREATE PROCEDURE VALIDANUMERO @NUMERO INT
AS
BEGIN --COMEÇO DO BLOCO TSQL
		IF @NUMERO = 5 -- EXPRESSAO BOOLEANA - TRUE
			PRINT 'O VALOR É VERDADEIRO'
		ELSE
			PRINT 'O VALOR É FALSO'
END --FIM DO BLOCO TSQL
GO

ALTER PROCEDURE VALIDANUMERO @NUMERO INT
AS
BEGIN --COMEÇO DO BLOCO TSQL
		IF @NUMERO = 5 -- EXPRESSAO BOOLEANA - TRUE
			PRINT 'O VALOR '+ CAST(@NUMERO AS VARCHAR) +' É VERDADEIRO'
		ELSE
			PRINT 'O VALOR '+ CAST(@NUMERO AS VARCHAR) +' É FALSO'
END --FIM DO BLOCO TSQL
GO

EXEC VALIDANUMERO 8
GO

/* LOOPS WHILE */

DECLARE @I INT = 1
BEGIN 
		WHILE @I<15
		BEGIN 
			PRINT 'VALOR DE I = ' + CAST(@I AS VARCHAR)
			SET @I = @I +1
		END
END
GO