--COMEÇANDO A MODELAR
Quando não tem uma boa modelagem, pode levar ao sistema mostrar informações errôneas.

Hoje temos mais do que 3 formas normais, mas ao normalizarmos um banco até a sua terceira forma, é o suficiente para ter um trabalho limpo e libre de erros.

--PRIMEIRA FORMA NORMAL
/* UM VETOR COLEÇÃO DE ELEMENTOS DO MESMO TIPO */
1. TODO CAMPO VETORIZADO SE TORNARÁ OUTRA TABELA.

[AMARELO, AZUL, LARANJA, VERDE] - VETOR DE CORES
[KA, FIESTA, UNO, CIVIC] - VETOR DE CARROS

2. TODO CAMPO MULTIVALORADO SE TORNARÁ OUTRA TABELA.
QUANDO O CAMPO FOR DIVISÍVEL

3. TODA TABELA NECESSITA DE PELO MENOS UM CAMPO QUE IDENTIFIQUE TODO O REGISTRO COMO SENDO ÚNICO.
ISSO; E O QUE CHAMAMOS DE CHAVE PRIMARIA OU PRIMARY KEY
COLUNAS CAMPOS, REGISTRO LINHAS.

--CARDINALIDADE E OBRIGATORIEDADE
LADO ESQUERDO OBRIGATORIEDADE (FALSO OU VERDADEIRO )
LADO DIREITO CARDINALIDADE (NO MÁXIMO 1 OU +1)
0, N
0, 1
1, N
1, 1

SEMPRE OLHAR A CARDINALIDADE DAS DUAS TABELAS E FOR 1 , 1, ENTÃO SE DIZ 1 PARA 1.

1 - Conceitual
2- Logica 
3- Física

--CRIANDO TABELAS

CREATE TABLE CLIENTE (
IDCLIENTE INT NOT NULL PRIMARY KEY (AUTOINCREMENTE) ,
NOME VARCHAR(200) NOT NULL,
SEXO CHAR(1) NOT NULL,
EMAIL VARCHAR(50) UNIQUE,
CPF VARCHAR(100) UNIQUE
);

CREATE TABLE TELEFONE(
     IDTELEFONE INT NOT NULL PRIMARY KEY (AUTOINCREMENTE) ,
     NUMERO VARCHAR(30) UNIQUE,
     TIPO INT NOT NULL,
     ID_CLIENTE INT,
            FOREIGN KEY (ID_CLIENTE)
            REFERENCES CLIENTE(IDCLIENTE)
);

CREATE TABLE ENDERECO(
     IDENDERECO INT PRIMARY KEY (AUTOINCREMENTE) ,
     RUA VARCHAR(30) NOT NULL,
     BAIRRO VARCHAR(30) NOT NULL,
     CIDADE VARCHAR(30) NOT NULL,
     ESTADO CHAR(2) NOT NULL,
     ID_CLIENTE INT UNIQUE,
            FOREIGN KEY (ID_CLIENTE)
            REFERENCES CLIENTE(IDCLIENTE)
);

Endereco - obrigatorio
cadastro de somente um.

Telefone - não obrigatorio
cadastro de mais de um (opcional)

FK / CHAVE ESTRANGEIRA
É a chave primaria de uma tabela que vai até a outra tabela para fazer referência entre registros

A FK depende da cardionalidade
REGRA 1,N
Em relacionamentos (1,n) a chave estrangeira sempre ficará na cardinalidade N

REGRA 1,1
Em relacionamento (1,1) a chave estrangeira fica na tabela mais fraca exemplo (cliente/endereço a fk fica no endereço porque é a mais fraca e obrigatoriamente sempre vai ter um cliente e nem sempre um endereço)

USAR O  (_ UNDERLINE) PARA REFERENCIAR COMO FK

Constraint (REGRA)

--INSERINDO DADOS
VALIDAR OS TIPOS DE CAMPOS DA TABELA QUE IRÁ INSERIR 

INSERT NORMAL LEMBRAR DE VALIDAR A QUANTIDADE DE COLUNAS E AFINS

--INSERÇÕES EM RELACIONAMENTO 1,1

BASTA PASSAR A FK CORRETA QUE EXISTA NA TABELA QUE REFERENCIA.

EM RELAICONAMENTO 1,1 A CHAVE ESTRANGEIRA NÃO SE REPETE
COLOCAR UNIQUE NA COLUNA DA FK

--INSERÇÕES EM RELAICONAMENTO 1,N

BASTA PASSAR A FK CORRETA QUE EXISTA NA TABELA QUE REFERENCIA.

EM RELAICONAMENTO 1,N A CHAVE ESTRANGEIRA SE REPETE QUANTAS VEZES FOR NECESSÁRIO
NÃO COLOCAR UNIQUE NA COLUNA DA FK

--SELEÇÃO, PROJEÇÃO E JUNÇÃO--

/* PROJEÇÃO */

PROJEÇÃO É TUDO QUE VOCÊ QUER VER NA TELA/ PODE VIR DE TABELAS OU PODE SER PROGRAMADA

/* SELEÇÃO */

SELEÇÃO É O SUBCONJUNTO DO TOTAL DE REGISTRO DE UMA TABELA
A CLAUSULA DE SELAÇÃO É O WHERE
FILTRAGEM DE INFORMAÇÕES VINDA DO BANCO SE VOCÊ DISTIRNGUIR HOMENS DE MULHESRES E GERA UM SUBCONJUNTO É UMA SELEÇÃO

EX1: SELECT NUMERO --PROJEÇÃO
FROM TELEFONE --ORIGEM
WHERE TIPO = 'CEL' --SELAÇÃO

EX2: SELECT NOME, SEXO, EMAIL --PROJEÇÃO
FROM CLIENTE --ORIGEM
WHERE SEXO = 'F' --SELEÇÃO

/* JUNÇÃO - > JOIN */

--DUAS OU MAIS TABELAS

--INNER JOIN
SELECT NOME, SEXO, BAIRRO, CIDADE --
FROM CLIENTE --ORIGEM
INNER JOIN ENDERECO --JUNCAO
ON IDCLIENTE = ID_CLIENTE
WHERE SEXO = 'F'


--LEFT JOIN
SELECT NOME, SEXO, TIPOS, NUMERO --
FROM CLIENTE --ORIGEM
LEFT JOIN TELEFONE --JUNCAO
ON IDCLIENTE = ID_CLIENTE
WHERE SEXO = 'F'

VOCÊ PODE JUNTAR QUANTAS TABELAS PRECISAR. O USO DA CLÁUSULA JOIN É IRRESTRITO, LÓGICAMENTE DEPENDENDO DO PROCESSAMENTO

QUANDO APARECE "DUPLICADO" EM ALGUNS CASOS VALIDAR A TABELA N, POIS LÁ VAI TER MAIS DE UMA INFORMAÇÃO, VISTO QUE É N

QUANDO VOCÊ COOLOCA UM ALIAS E PONTERA O SQL FICA MAIS RAPIDO, EXEMPLO: C.NOME, C.SEXO...

 
 /* 
     DML - DATA MANIPULATION LANGUAGE - MANIPULAÇÃO
     DDL - DATA DEFINITION LANGUAGE - TIPAGEM
     DCL - DATA CONTROL LANGUAGE - CONTROLE DE ACESSO AOS DADOS
     TCL - TRANSACTION CONTROL LANGUAGE - CONTROLE DE TRANSAÇÃO
 */

/* DML - DATA MANIPULATION LANGUAGE - MANIPULAÇÃO */ 
/* INSERT */ 
INSERT INTO CLIENTE VALUES(NULL, 'PAULA', 'M', NULL, '8349018540');
INSERT INTO ENDERECO VALUES(NULL, 'RUA JOAQUIM SILVA', 'ALVORADA', 'NITEROI', 'RJ', ID_CLIENTE);
SELECT * FROM CLIENTE

/* FILTROS */ 
SELECT * FROM CLIENTE 
WHERE ID_CLIENTE = 'M'
AND IDCLIENTE = 7;

/* UPDATE */ 
SELECT * FROM CLIENTE 
WHERE ID_CLIENTE = 'M'
AND IDCLIENTE = 7;

UPDATE C SET SEXO = 'F' FROM CLIENTE C
WHERE C.ID_CLIENTE = 'M'
AND C.IDCLIENTE = 7;

/* DELETE */ 
SELECT * FROM CLIENTE C
WHERE C.IDCLIENTE = 8;

DELETE C FROM CLIENTE C
WHERE C.IDCLIENTE = 8;

/* DDL - DATA DEFINITION LANGUAGE - TIPAGEM */ 

COLUNA 'NOME' TIPO = VARCHAR DEFININDO O TIPO É DDL

CREATE TABLE PRODUTO(
     IDPRODUTO INT PRIMARY KEY AUTOINCREMENTE,
     NOME_PRODUTO VARCHAR(100) NOT NULL,
     PREÇO FLOAT,
     FRETE FLOAT(10,2) NOT NULL

)

/* ALTER TABLE */

/* ALTERANDO O NOME DE UMA TABELA - CHANGE */
ALTER TABLE PRODUTO
CHANGE PRECO VALOR_UNITARIO INT NOT NULL; -- MYSQL

ALTER TABLE PRODUTO
CHANGE VALOR_UNITARIO VALOR_UNITARIO INT; -- MYSQL
DESC PRODUTO

/* MODIFY - ALTERANDO O TIPO */

ALTER TABLE PRODUTO
MODIFY VALOR_UNITARIO VARCHAR(50) NOT NULL

/* ADD ADICIONANDO COLUNAS */
ALTER TABLE PRODUTO
ADD COLUMN PESO FLOAT(10,2) NOT NULL;
-- INDEPENDETE DA ORDEM DAS COLUNAS, NA PROJEÇÃO, VOCÊ PODE COLOCAR EM QUALQUER POSIÇÃO

/* APAGANDO UMA COLUNA */

ALTER TABLE PRODUTO
DROP COLUMN PESO;

/* ADD ADICIONANDO UMA COLUNAS NA ORDERM ESPECIFICA*/
ALTER TABLE PRODUTO
ADD COLUMN PESO FLOAT(10,2) NOT NULL,
AFTER NOME_PRODUTO;

ALTER TABLE PRODUTO
ADD COLUMN PESO FLOAT(10,2) NOT NULL,
FIRST NOME_PRODUTO;

/* EXERCICIOS DML */

/* RELATORIO GERAL DE TODOS OS CLIENTES */
SELECT C.IDCLIENTE, C.NOME, C.SEXO, C.EMAIL, C.CPF, E.RUA, E.BAIRRO, E.CIDADE, E.ESTADO, T.TIPO, T.NUMERO
FROM CLIENTE C
INNER JOIN ENDERECO E
ON C.IDCLIENTE = E.ID_CLIENTE 
INNER JOIN TELEFONE T
ON C.IDCLIENTE = T.ID_CLIENTE;

/* RELATORIO DE HOMENS */
SELECT C.IDCLIENTE, C.NOME, C.SEXO, C.EMAIL, C.CPF, E.RUA, E.BAIRRO, E.CIDADE, E.ESTADO, T.TIPO, T.NUMERO
FROM CLIENTE C
INNER JOIN ENDERECO E
ON C.IDCLIENTE = E.ID_CLIENTE 
INNER JOIN TELEFONE T
ON C.IDCLIENTE = T.ID_CLIENTE
WHERE C.SEXO = 'M';

/* RELATORIO DE MULHERES */
SELECT C.IDCLIENTE, C.NOME, C.SEXO, C.EMAIL, C.CPF, E.RUA, E.BAIRRO, E.CIDADE, E.ESTADO, T.TIPO, T.NUMERO
FROM CLIENTE C
INNER JOIN ENDERECO E
ON C.IDCLIENTE = E.ID_CLIENTE 
INNER JOIN TELEFONE T
ON C.IDCLIENTE = T.ID_CLIENTE
WHERE C.SEXO = 'F';

/* QUANTIDADE DE HOMENS E MULHERES */
SELECT COUNT(SEXO) AS QUANTIDADE, SEXO
FROM CLIENTE
GROUP BY SEXO;

/* IDS E EMAIL DAS MULHERES QUE MORAM NO CENTRO DO RIO DE JANEIRO E NÃO TEM CELULAR */
SELECT C.IDCLIENTE, C.NOME, C.SEXO, C.EMAIL, E.BAIRRO, E.CIDADE
FROM CLIENTE C
INNER JOIN ENDERECO E
E.ID_CLIENTE = C.IDCLIENTE
WHERE C.SEXO = 'F' 
AND BAIRRO LIKE 'CENTRO' 
AND ESTADO LIKE 'RJ' 
AND (T.TIPO = 'RES' OR T.TIPO = 'COM' --SEM O TIPO 'CEL')

SELECT C.IDCLIENTE, C.NOME, C.SEXO, C.EMAIL, E.BAIRRO, E.CIDADE
FROM CLIENTE C
INNER JOIN ENDERECO E
E.ID_CLIENTE = C.IDCLIENTE
WHERE C.SEXO = 'F' 
AND BAIRRO LIKE 'CENTRO' 
AND ESTADO LIKE 'RJ' 
AND IDCLIENTE NOT IN (SELECT ID_CLIENTE FROM TELEFONE WHRE T.TIPO = 'RES' OR T.TIPO = 'COM' --SEM O TIPO 'CEL')

/* PARA UMA CAMPANHA DE MARKETING, O SETOR SOLICITOU UM RELATÓRIO COM O NOME, EMAIL E TELEFONE CELULAR
DOS CLIENTE QUE MORA NO ESTADO DO RIO DE JANEIRO. */
SELECT C.NOME, C.EMAIL, T.NUMERO AS CELULAR
FROM CLIENTE C
INNER JOIN TELEFONE T 
ON C.IDCLIENTE = T.ID_CLIENTE AND T.TIPO = 'CEL'
INNER JOIN ENDERECO E
ON C.IDCLIENTE = E.ID_CLIENTE AND E.ESTADO = 'RJ'

/* PARA UMA CAMPANHA DE PRODUTOS DE BELEZA, O COMERCIAL SOLICITOU UM RELATÓRIO COM O NOME, EMAIL E TELEFONE CELULAR
DAS MULHERES QUE MORAM NO ESTADO DE SÃO PAULO. */
SELECT C.NOME, C.EMAIL, T.NUMERO AS CELULAR
FROM CLIENTE C
INNER JOIN TELEFONE T 
ON C.IDCLIENTE = T.ID_CLIENTE AND C.SEXO = 'F' AND T.TIPO = 'CEL'
INNER JOIN ENDERECO E
ON C.IDCLIENTE = E.ID_CLIENTE AND E.ESTADO = 'SP'

--A TABELA DE ORIGEM É SEMPRE A QUE TEM MAIS VINCULO;


/* FUNÇÕES IFNULL */
--UMA FUNÇÃO É UM BLOCO DE PROGRAMAÇÃO QUE EXECUTA ALGUMA COISA
--FUNÇÕES COM E SEM PARÂMETRO E NOSSAS PROPRIAS FUNÇÕES

SELECT C.IDCLIENTE, 
C.NOME, 
C.SEXO, 
IFNULL(C.EMAIL, '*********') AS EMAIL --MYSQL
FROM CLIENTE C
INNER JOIN ENDERECO E
ON C.IDCLIENTE = E.ID_CLIENTE 
INNER JOIN TELEFONE T
ON C.IDCLIENTE = T.ID_CLIENTE;


/* VIEWS - VISÕES */
--UMA VIEW FUNCIONA COMO PONTEIRO QUE APONTO PARA A QUERY
/* SEMPRE TENHA BACKUP DAS QUERYS */
SELECT 
C.NOME, 
C.SEXO, 
C.EMAIL, 
T.TIPO, T.NUMERO, 
E.AIRRO, 
E.CIDADE, 
E.ESTADO
FROM CLIENTE C 
INNER JOIN TELEFONE T
ON C.IDCLIENTE = T.ID_CLIENTE
INNER JOIN ENDERECO E
ON C.IDCLIENTE = T.ID_CLIENTE

--VIEW É BASICAMENTO UMA TABELA VIRTUAL

DROP VIEW V_RELATORIO;

/* INSERINDO UM PREFIXO */

CREATE VIEW V_RELATORIO AS 
SELECT 
C.NOME, 
C.SEXO, 
IFNULL(C.EMAIL, 'CLIENTE SEM EMAIL') AS EMAIL,
T.TIPO, 
T.NUMERO, 
E.AIRRO, 
E.CIDADE, 
E.ESTADO
FROM CLIENTE C 
INNER JOIN TELEFONE T
ON C.IDCLIENTE = T.ID_CLIENTE
INNER JOIN ENDERECO E
ON C.IDCLIENTE = T.ID_CLIENTE

/* VIEW PERDE PERFORMANCE, MAS É UM MAL NECESSÁRIO PARA FICAR MAIS FÁCIL */
/* NÃO PODE INSERIR OU DELETAR EM UMA VIEW COM JOIN POREM, SEM JOIN DÁ */
/* É PERMITIDO FAZER UM UPDATE EM VIEW, PORÉM NÃO É VIAVEL, VISTO QUE DEVE-SE ANALISAR OS DADOS */


/* ORDENANDO POR DADOS */
-- A UNICA FORMA DE ORNDENAR UMA TABELA É UTILIZANDO O COMANDO ORDER BY. SEM ELE, O RESULTADO É ALEATÓRIO.
-- PODE SER ORDENADO PELO INDICE DA COLUNA /NOME.
-- NA PROJEÇÃO ELE ENTENDO COMO UM NOVO INDICE, SE VOCÊ ESTIVER USANDO PARA ORDENA POR NUMERO, COLOCAR APENAS UMA COLUNA NA PROJEÇÃO E NA ORDENAÇÃO 1,2 ELE 
-- NÃO VAI ENTENDER VISTO QUE NÃO TEM OUTRA COLUNA NA PROJEÇÃO. DESTA FORMA, É NECESSÁRIO ORDENAR POR NOME DE COLUNA.
EX ERRADO:SELECT NOME 
          FROM ALUNOS
          ORDER BY 1,2

EX CERTO: SELECT NOME
          FROM ALUNOS
          ORDER BY NUMERO, NOME

/* 63. 34 - Notação de Cross e o Star UML */
-- NO BR MODELO É POR NUMERO, NO STAR UML É POR LINHAS.

/* DELIMITER */
--PARA VALIDAR OS AS INFORMAÇÕES RELACIONADAS AO MNYSQL
STATUS 
-- PARA MUDAR O DELIMITADOR
DELIMITER $

/* 65. 58 Iniciando com Programação em Bancos de Dados */
/* STORED PROCEDURES */
/* BLOCO ANONIMO - NÃO ARMAZENA NO BANCO */
SELECT 'MAFRA' --NÃO FICA ARMAZENADO NO BANCO É UMA PROGRAMAÇÃO PARA TEMPO DE EXECUÇÃO.

/* NO MYSQL É IMPORTANTE MUDAR O DELIMITADOR PARA EXECUTAR PROCEDIMENTOS, VISTO QUE NA PROCEDURE É NECESSÁRIO COLOCAR O ;
CASO NÃO MUDE IRÁ PARAR QUANDO O SQL ENCONTRAR O DELIMITADOR PARANDO O SISTEMA. */

/* BLOCO NOMEADOR - ARMAZENA NO BANCO */
DELIMITER $
CREATE PROCEDURE NOME()
BEGIN
   -- QUALQUER PROGRAMAÇÃO
END
$ --DELIMITER NOVO

/* APAGANDO PROCEDURE */
DROP PROCEDURE NOME();

/* PROCEDURE SEM PARAMETOS */
CREATE PROCEDURE NOME_EMPRESA()
BEGIN
    SELECT 'TESTE' EMPRESA;
END
$

DELIMITER ;
/* CHAMANDO UMA PROCEDURE */
CALL NOME_EMPRESA();

/* PROCEDURE COM PARAMETOS */
DELIMITER $
CREATE PROCEDURE SOMA(VALOR1 INT, VALOR2 INT) -- NOS PARAMETRO TEM QUE TER OS TIPOS
BEGIN
    SELECT VALOR1 + VALOR2 EMPRESA;
END
$
DELIMITER ;

CALL SOMA(10,2);

/* 66. 59 Procedures no Mundo Real */

/* Nesta aula, o professor abordou o conceito de programação com passagem de parâmetros e sem passagem de parâmetros. Ele explicou que a passagem de parâmetros 
permite realizar diferentes tipos de programação, como cadastro em uma tabela, formatação de dados, comparações, entre outros.*/

/* Ele também introduziu a arquitetura MVC (Model-View-Controller), que consiste em três camadas: visão, controle e modelo. A camada de visão é responsável pela 
interface do usuário, onde os dados são inseridos. A camada de controle processa as regras de negócio e a camada de modelo representa o banco de dados.*/

/* Existem diferentes abordagens em relação à colocação das regras de negócio, sendo uma delas mantê-las na camada de controle, onde o processamento é feito no 
servidor de aplicação. Outra abordagem é transferir parte das regras de negócio para o banco de dados, facilitando a migração entre diferentes bancos, 
mas tornando a migração das regras de negócio mais difícil. */

/* O professor mencionou a importância de proteger as consultas SQL para evitar injeção de SQL. Ele explicou que em páginas de pesquisa, 
por exemplo, é recomendado usar parâmetros para evitar problemas de segurança.*/

/*
Aqui estão alguns exemplos de SQL Injection para ilustrar como um invasor pode explorar vulnerabilidades em uma aplicação:

Exemplo de autenticação:
Suponha que uma aplicação tenha uma consulta SQL para verificar as credenciais do usuário durante o processo de login:
sql
Copy code
SELECT * FROM users WHERE username = '<username>' AND password = '<password>';
Um atacante pode tentar inserir uma sequência maliciosa no campo de usuário para contornar a autenticação:

sql
Copy code
' OR '1'='1' --
A consulta resultante se tornaria:

sql
Copy code
SELECT * FROM users WHERE username = '' OR '1'='1' --' AND password = '<password>';
Isso faria com que a condição sempre retornasse verdadeira, permitindo que o atacante acesse a conta de qualquer usuário sem fornecer a senha correta.

Exemplo de exibição de dados confidenciais:
Suponha que uma aplicação permita aos usuários pesquisar por produtos em um banco de dados:
sql
Copy code
SELECT * FROM products WHERE name LIKE '%<search_term>%';
Se a entrada do usuário não for sanitizada corretamente, um invasor pode explorar isso para exibir dados confidenciais:

sql
Copy code
' OR 1=1; DROP TABLE products; --
A consulta resultante se tornaria:

sql
Copy code
SELECT * FROM products WHERE name LIKE '%' OR 1=1; DROP TABLE products; -- '%';
Isso executaria uma injeção de SQL, retornando todos os produtos e, em seguida, excluindo a tabela de produtos do banco de dados.

Esses são apenas exemplos básicos para ilustrar como um ataque de SQL Injection pode ser realizado. Existem várias variações e técnicas mais avançadas que um invasor pode empregar para explorar vulnerabilidades e comprometer a segurança de uma aplicação. É fundamental implementar práticas robustas de segurança para evitar a exploração de SQL Injection.
*/

/* COMO PREVINIR
Sim, uma forma eficaz de prevenir ataques de SQL Injection é usar parâmetros em consultas SQL. Em vez de concatenar diretamente os valores de entrada na consulta, os parâmetros são usados para transmitir os dados para o banco de dados de forma segura. Dessa forma, o banco de dados trata esses valores como dados brutos, eliminando a possibilidade de interpretação maliciosa dos mesmos.

Ao usar parâmetros, a consulta SQL é pré-compilada com espaços reservados para os valores dos parâmetros. Esses valores são enviados separadamente e não são interpretados como parte da consulta SQL em si. Isso impede que os dados de entrada do usuário sejam confundidos com comandos SQL.
*/

/* 67.60 - Procedures com Query - PARÂMETROS */
/* PROCEDURES */
CREATE DATABASE PROJETO;
USE PROJETO

CREATE TABLE CURSOS (
  IDCURSO INT PRIMARY KEY AUTO_INCREMENTE,
  NOME VARCHAR (100) NOT NULL,
  HORAS INT(3) NOT NULL,
  VALOR FLOAT(10,2) NOT NULL
);

INSERT INTO CURSOR VALUES (NULL, 'TESTE CURSO', 20, 300.00);
DELIMITER $
CREATE PROCEDURE INSERTCURSOS(P_NOME VARCHAR (100), P_HORAS INT(3), P_VALOR FLOAT(10,2))
BEGIN
     INSERT INTO CURSOS VALUES (NULL, P_NOME, P_HORAS, P_VALOR);
END
$

DELIMITER :

CALL INSERTCURSOS('TESTE PROCEDURE 1', 20, 100.00);
CALL INSERTCURSOS('TESTE PROCEDURE 2', 12, 200.00);
CALL INSERTCURSOS('TESTE PROCEDURE 3', 13, 123.00);
CALL INSERTCURSOS('TESTE PROCEDURE 4', 14, 111.00);
CALL INSERTCURSOS('TESTE PROCEDURE 5', 15, 109.00);
CALL INSERTCURSOS('TESTE PROCEDURE 6', 16, 30.00);
CALL INSERTCURSOS('TESTE PROCEDURE 7', 17, 60.00);
CALL INSERTCURSOS('TESTE PROCEDURE 9', 18, 90.00);

/* CRIAR UMA PRO */

DELIMITER #

CREATE PROCEDURE LE_CURSO( P_IDCURSO INT )
BEGIN
        SELECT NOME, HORAS, VALOR FROM CURSOS
        WHERE IDCURSO =  P_IDCURSO;
END
#

DELIMITER ;

CALL LE_CURSO( 2 );

/* 70. Group By, Count, Max, Min, Avg e funções do MySQL */

CREATE TABLE VENDEDORES(
    IDVENDEDOR INT PRIMARY KEY AUTO_INCREMENTE,
    NOME VARCHAR(100) NOT NULL,
    SEXO ENUM('F', 'M'),
    JANEIRO FLOAT(10,2),
    FEVEREIRO FLOAT(10,2),
    MARCO FLOAT(10,2)
);

INSERT INTO VENDEDORES VALUES (NULL, 'CARLOS', 'M', 2356.00, 346.00, 4745.00);
INSERT INTO VENDEDORES VALUES (NULL, 'JOAO', 'M', 5634.00, 20432.00, 3000.00);
INSERT INTO VENDEDORES VALUES (NULL, 'MARIA', 'F', 4641.00, 34.00, 9879.00);
INSERT INTO VENDEDORES VALUES (NULL, 'CARLA', 'F', 10150.00, 135.00, 856.00);
INSERT INTO VENDEDORES VALUES (NULL, 'FABRICIO', 'M', 512.05, 25500.00, 44564.00);
INSERT INTO VENDEDORES VALUES (NULL, 'VINICIUS', 'M', 3483.45, 5135.00, 5643.00);
--FUNÇÕES DE AGRAÇÃO

-- MAX - TRAZ O VALOR MAXIMO DE UMA COLUNA
SELECT NOME, MAX(FEVEREIRO) AS MAIOR_FEV 
FROM CLIENTE;

-- MIN - TRAZ O VALOR MINIMO DE UMA COLUNA
SELECT NOME, MIN(FEVEREIRO) AS MIN_FEV 
FROM CLIENTE;

-- VARIA FUNÇÕES
SELECT NOME, 
MAX(FEVEREIRO) AS MAIOR_FEV,
MIN(FEVEREIRO) AS MIN_FEV,
AVG(FEVEREIRO) AS MEDIA_FEV 
FROM CLIENTE;

-- TRUNCATE PEDE UM NUMERO QUALQUER E O NUMERO DE CASAS DECIMAIS
SELECT NOME, 
MAX(FEVEREIRO) AS MAIOR_FEV,
MIN(FEVEREIRO) AS MIN_FEV,
TRUNCATE(AVG(FEVEREIRO), 2) AS MEDIA_FEV 
FROM CLIENTE;

--UTILIZANDO O SUM

SELECT SUM(JANEIRO) AS SOMA_JAN
FROM VENDEDORES;

SELECT SUM(JANEIRO) AS SOMA_JAN,
SUM(FEVEREIRO) AS SOMA_FEV,
SUM(MARCO) AS SOMA_MARC
FROM VENDEDORES;

/* PREMISSA DE BANCO DE DADOS - ARMAZENA DADOS E COM ELES GERA INFORMAÇÕES */

SELECT SEXO,
SUM(MARCO) AS SOMA_MARC
FROM VENDEDORES
GROUP BY SEXO;

/* UTILIZANDO SUBQUERY */
-- A INNER QUERY É RESOLVIDA PRIMEIRO SEMPRE
/* VENDEDOR QUE VENDEU MENOS EM MARCO E O SEU NOME */
SELECT NOME,
MARCO
FROM VENDEDORES
WHERE MARCO
 = (SELECT MIN(MARCO) AS MARCO FROM VENDEDORES);

/* VENDEDOR QUE VENDEU MAIS EM MARCO E O SEU NOME */
SELECT NOME,
MARCO
FROM VENDEDORES
WHERE MARCO
 = (SELECT MAX(MARCO) AS MARCO FROM VENDEDORES);

/* VENDEDOR QUE VENDEU MAIS QUE A MEDIA E O SEU NOME */
SELECT NOME,
FEVEREIRO
FROM VENDEDORES
WHERE MARCO
 > (SELECT AVG(FEVEREIRO) AS MARCO FROM VENDEDORES);

 /* 73. OPERAÇÕES EM LINHAS */

 SELECT NOME,
        JANEIRO,
        FEVEREIRO,
        MARCO,
        (JANEIRO + FEVEREIRO + MARCO) AS "TOTAL",
        (JANEIRO + FEVEREIRO + MARCO) * 0.25 AS "DESCONTO",
        TRUNCATE((JANEIRO + FEVEREIRO + MARCO)/3. 2) AS "MEDIA",
        TRUNCATE((JANEIRO - FEVEREIRO - MARCO)/3. 2) AS "MENOS"
FROM VENDEDORES;

/* 74. Verificando e alterando a estrutura de uma tabela, seus objetos e charsets */

CREATE TABLE TABELA (
    COLUNA1 VARCHAR(30),
    COLUNA2 VARCHAR(30),
    COLUNA3 VARCHAR(30)
)

--ALTERANTO A TABELA NÇAI É POSSÍVEL ADD O AUTO_INCREMENT
ALTER TABLE TABELA
ADD PRIMARY KEY (COLUNA1);

--ADICIONANDO COLUNA SE VOCê NÃO ESPECIFICA ELE VAI PARA ULTIMA
ALTER TABLE TABELA
ADD COLUNA VARCHAR(40);

--ADICIONANDO COLUNA COM POSICAO
ALTER TABLE TABELA
ADD COLUNA4 VARCHAR(40) NOT NULL UNIQUE
AFTER COLUNA3;

--MODIFICANDO O TIPO DE UM CAMPO
ALTER TABLE TABELA
MODIFY COLUNA2 DATE NOT NULL;
--LEMBRANDO QUE PARA TABELAS COM DADOS, OS DADOS TEM QUE SER DO TIPO QUE EU ESTOU MODIFICANDO;

--RENOMEANDO O NOME DA TABELA
ALTER TABLE TABELA
RENAME PESSOA;

CREATE TABLE TIME(
    IDTIME INT PRIMARY KEY AUTO_INCREMENTE,
    TIME VARCHAR(30),
    ID_PESSOA VARCHAR(30)
);

--ADICIONANDO FOREING KEY
ALTER TABLE TIME 
ADD FOREIGN KEY (ID_PESSOA)
REFERENCES PESSOA(COLUNA1);

/* VERIFICAR AS CHAVES */
SHOW CREATE TABLE TIME;

--CHARSET É COMO OS DADOS VÃO SER ARMAZENADOS, EM QUAL LINGUAGEM POR EXEMPLO O LATIM TEM Ç E OUTROS NÃO;

/* ORGANIZAÇÃO DE CHAVES - CONSTRIANT (REGRA) */
-- A CHAVE PRIMARIA ELA SEMPRE VAI SER GERADO, CASO ALGUM DADO SEJA EXCLUIDO, AQUELE DADO NÃO É RECRIADO, MAS SIM PULADO.
-- INTEGRIDADE REFERENCIAL. o BANCO SEMPRE EM CHAVES ESTRANGEIRAS VAI OBRIGAR TER NA CHAVE PRIMARIA

/* QUANDO A CONSTRAINT É CRIADA DENTRO DA TABELA, O BANCO DÁ UM NOME ALEÁTORIO PARA A CONSTRAINT
O IDEAL É CRIAR A TABELA E DEPOIS ADICIONAR A CONSTRINAT. */

/* 76. Constraints Nomeadas x Dicionário de Dados */
-- SEMPRE CRIAR TODAS AS TABELAS PRIMEIRO E DEPOIS TODAS AS CONSTRAINTS

CREATE TABLE CLIENTE (
    IDCLIENTE INT,
    NOME VARCHAR(50) NOT NULL
);

CREATE TABLE TELEFONE (
    IDTELEFONE INT,
    TIPO CHAR(3) NOT NULL,
    NUMERO VARCHAR(50) NOT NULL
    ID_CLIENTE INT
);

ALTER TABLE CLIENTE ADD CONSTRINAT PK_CLIENTE
PRIMARY KEY (IDCLIENTE);

ALTER TABLE TELEFONE ADD CONSTRINAT FK_CLIENTE_TELEFONE
FOREIGN KEY (ID_CLIENTE) REFERENCES CLIENTE(IDCLIENTE);

-- A TABELA CLIENTE SE REFERENCIA A TABELA TELEFONE;
SHOW CREATE TABLE TELEFONE;
/* DICIONARIOS DE DADOS */

-- AS TABELAS PADRÕES DO BANCO DE DADOS GUARDA O METADADO ELE ARMAZENA NOME, COLUNAS ETC...
SHOW DATABASE;

USE INFORMATION_SCHEMA

STATUS

/* APAGANDO CONSTRAINT */
USE COMERCIO

ALTER TABLE TELEFONE
DROP FOREIGN KEY FK_CLIENTE_TELEFONE

ALTER TABLE TELEFONE ADD CONSTRINAT FK_CLIENTE_TELEFONE
FOREIGN KEY (ID_CLIENTE) REFERENCES CLIENTE(IDCLIENTE);

-- DROPAR A CONSTRAINT SERVER PARA INSERÇÃO EM MASSA DE DADOS PARA QUE O BANCO NÃO VALIDE CADA REFERENCIA.

-- (N, N) RELACIONAMENTOS N PARA N CRIA-SE UMA TERCEIRA TABELA 

/* 79. O sistema do Seu José - A oficina! */

-- TAREFA 1 RealizadA no BRModelo

CREATE DATABASE PROJETO;

USE PROJETO;

CREATE TABLE CLIENTE (
    IDCLIENTE INT PRIMARY KEY AUTO_INCREMENT,
    NOME VARCHAR(50) NOT NULL,
    SEXO ENUM('F','M') NOT NULL,
    EMAIL VARCHAR(50),
    ID_CARRO INT UNIQUE
);

CREATE TABLE CARRO (
    IDCARRO INT PRIMARY KEY AUTO_INCREMENT,
    NOME VARCHAR(50) NOT NULL,
    ID_CLIENTE INT,
    ID_MARCA INT
);

CREATE TABLE MARCA (
    IDMARCA INT PRIMARY KEY AUTO_INCREMENT,
    NOME VARCHAR(50) UNIQUE
);

CREATE TABLE COR (
    IDCOR INT PRIMARY KEY AUTO_INCREMENT,
    NOME VARCHAR(50) UNIQUE
);

CREATE TABLE CARRO_COR ( --TABELA ASSOCIATIVA
    ID_CARRO INT,
    ID_COR INT,
    PRIMARY KEY (ID_CARRO, ID_COR)
);

CREATE TABLE TELEFONE (
    IDTELEFONE INT PRIMARY KEY AUTO_INCREMENT,
    NUMERO VARCHAR(50) NOT NULL,
    TIPO ENUM('RES', 'CEL', 'COM'),
    ID_CLIENTE INT
);

ALTER TABLE CLIENTE
ADD CONSTRAINT FK_CLIENTE_CARRO
FOREIGN KEY ID_CARRO REFERENCES CARRO(IDCARRO);

ALTER TABLE CARRO
ADD CONSTRAINT FK_CARRO_MARCA
FOREIGN KEY ID_MARCA REFERENCES MARCA(IDMARCA);

ALTER TABLE TELEFONE 
ADD CONSTRAINT FK_TELEFONE_CLIENTE
FOREIGN KEY (ID_CLIENTE) REFERENCES CLIENTE(IDCLIENTE);

ALTER TABLE CARRO_COR 
ADD CONSTRAINT FK_CARRO
FOREIGN KEY (ID_CARRO) REFERENCES CARRO(IDCARRO);

ALTER TABLE CARRO_COR 
ADD CONSTRAINT FK_COR
FOREIGN KEY (ID_COR) REFERENCES COR(IDCOR);

/* 82. Introdução às fantásticas Triggers */

-- ESTRUTURA DE UMA TRIGGER - GATILHO
DELIMITER -
CREATE TRIGGER NOME
BEFORE/AFTER INSERT/DELETE/UPDATE ON TABELA
FOR EACH ROW
BEGIN -> INICIO



END -> FIM
-

DELIMITER ;

CREATE DATABASE AULA40;

CREATE TABLE USUARIO (
    IDUSUARIO INT PRIMARY KEY AUTO_INCREMENT,
    NOME VARCHAR(30) NOT NULL,
    LOGIN VARCHAR(30) NOT NULL,
    SENHA VARCHAR(30) NOT NULL
)

CREATE TABLE BKP_USUARIO (
    IDBKP INT PRIMARY KEY AUTO_INCREMENT,
    IDUSUARIO INT,
    NOME VARCHAR(30) NOT NULL,
    LOGIN VARCHAR(30) NOT NULL,
)

-- INSERT (SE O VALOR JÁ EXISTE NA TABELA, ENTÃO É OLD. SE O VALOR SERÁ INSERIDO, ELE É NEW)
-- UPDATE (O VALOR QUE SERÁ ATUALIZADO É NEW E O QUE ESTÁ SAINDO É OLD)

DELIMITER -
CREATE TRIGGER INSEREBKP
BEFORE DELETE ON USUARIO
FOR EACH ROW
BEGIN -> INICIO

    INSERT INTO BKP_USUARIO(NULL, OLD.IDUSUARIO, OLD.NOME, OLD.LOGIN)

END -> FIM
-

DELIMITER ;


-- /* 84. Triggers para bancos de backups */
-- BACKUP LOGICO UM BANCO QUE CRIAMOS NA MESMA INSTÂNCIA E SEMPRE QUE FOR INSERIDA QUALQUER COISA NO OUTRO BANCO É CRIADO UMA TRIGGER PARA SER INSERIDA NA NOVA.
-- COMUNICAÇÃO ENTRE BANCOS

-- AFTER ANTES 
-- BEFORE DEPOIS

CREATE DATABSE LOJA;

USE LOJA;

CREATE TABLE PRODUTO (
    IDPRODUTO INT PRIMARY KEY AUTO_INCREMENT,
    NOME VARCHAR(30),
    VALOR FLOAT(10,2)
)

CREATE DATABSE BKP_LOJA;

USE BKP_LOJA;

CREATE TABLE BKP_PRODUTO (
    IDBKP INT PRIMARY KEY AUTO_INCREMENT,
    IDPRODUTO INT
    NOME VARCHAR(30),
    VALOR FLOAT(10,2)
)

USE LOJA;

INSERT INTO BKP_LOJA.BKP_PRODUTO VALUES(NULL, 1000, 'TESTE', 0.0)

DELIMITER $

CREATE TRIGGER BACKUP_PRODUT
BEFORE INSERT ON PRODUTO
FOR EACH ROW --MYSQL
BEGIN
    INSERT INTO BACKUP.BKP_PRODUTO VALUES(NULL, NEW.IDPRODUTO, NEW.NOME, NEW.VALOR)
END
$

DELIMITER :

INSERT INTO PRODUTO VALUES(NULL, 'Teste1', 0.00);
INSERT INTO PRODUTO VALUES(NULL, 'teste2', 0.00);
INSERT INTO PRODUTO VALUES(NULL, 'teste3', 0.00);
INSERT INTO PRODUTO VALUES(NULL, 'teste4', 0.00);


DELIMITER $

CREATE TRIGGER BACKUP_PRODUTO_DEL
BEFORE DELETE ON PRODUTO
FOR EACH ROW --MYSQL
BEGIN
    INSERT INTO BABKP_LOJACKUP.BKP_PRODUTO VALUES(NULL, OLD.IDPRODUTO, OLD.NOME, OLD.VALOR)
END
$

DELIMITER :

DROP TRIGGER BKP_LOJA.BACKUP_PRODUT;

DELIMITER $

CREATE TRIGGER BACKUP_PRODUTO_INS
AFTER INSERT ON PRODUTO
FOR EACH ROW --MYSQL
BEGIN
    INSERT INTO BKP_LOJA.BKP_PRODUTO VALUES(NULL, NEW.IDPRODUTO, NEW.NOME, NEW.VALOR)
END
$

DELIMITER :

/* After, Before, Insert, Delete ou Update? Os eventos de uma trigger */

ALTER TABLE BKP_LOJA.BKP_PRODUTO
ADD EVENTO CHAR(1);

DROP TRIGGER BKP_PRODUTO.BACKUP_PRODUTO_DEL;

DELIMITER $

CREATE TRIGGER BACKUP_PRODUTO_DEL
BEFORE DELETE ON PRODUTO
FOR EACH ROW --MYSQL
BEGIN
    INSERT INTO BACBKP_LOJAKUP.BKP_PRODUTO VALUES(NULL, NEW.IDPRODUTO, NEW.NOME, NEW.VALOR, 'D')
END
$

DELIMITER :

DROP TRIGGER BKP_LOJA.BACKUP_PRODUTO_INS;

DELIMITER $

CREATE TRIGGER BACKUP_PRODUTO_INS
AFTER INSERT ON PRODUTO
FOR EACH ROW --MYSQL
BEGIN
    INSERT INTO BKP_LOJA.BKP_PRODUTO VALUES(NULL, NEW.IDPRODUTO, NEW.NOME, NEW.VALOR, 'I')
END
$

DELIMITER :

/* 86. Quem mexeu no meu dado? Auditando uma tabela com trigger */

/* TRIGGER DE AUDITORIA */

DROP DATABASE LOJA;

DROP DATABASE BACKUP:

CREATE DATABASE LOJA;

USE LOJA;

CREATE TABLE PRODUTO (
    IDPRODUTO INT PRIMARY KEY AUTO_INCREMENT,
    NOME VARCHAR(30),
    VALOR FLOAT(10,2)
)


INSERT INTO PRODUTO VALUES(NULL, 'Teste1', 0.00);
INSERT INTO PRODUTO VALUES(NULL, 'teste2', 0.00);
INSERT INTO PRODUTO VALUES(NULL, 'teste3', 0.00);
INSERT INTO PRODUTO VALUES(NULL, 'teste4', 0.00);

CREATE DATABSE BKP_LOJA;

USE BKP_LOJA;

CREATE TABLE BKP_PRODUTO (
    IDBKP INT PRIMARY KEY AUTO_INCREMENT,
    IDPRODUTO INT
    NOME VARCHAR(30),
    VALORANTIGO FLOAT(10,2),
    VALORNOVO FLOAT(10,2),
    DATA DATETIME,
    USUARIO VARCHAR(20),
    EVENTO CHAR(1)

):


/* QAUNDO */
SELECT NOW()

/* QUEM */
SELECT CURRENT_USER()


DELIMITER $

CREATE TRIGGER BACKUP_PRODUTO_UPD
AFTER UPDATE ON PRODUTO
FOR EACH ROW --MYSQL
BEGIN
    INSERT INTO BKP_LOJA.BKP_PRODUTO VALUES(NULL, OLD.IDPRODUTO, OLD.NOME, OLD.VALORANTIGO , NEW.VALORNOVO, (SELECT NOW()), (SELECT CURRENT_USER()), 'U')
END
$

DELIMITER :

UPDATE PRODUTO SET VALOR = 110 WHERE IDPRODUTO = 4


DELIMITER $

CREATE TRIGGER BACKUP_PRODUTO_DEL
BEFORE DELETE ON PRODUTO
FOR EACH ROW --MYSQL
BEGIN
    INSERT INTO BKP_LOJA.BKP_PRODUTO VALUES(NULL, OLD.IDPRODUTO, OLD.NOME, OLD.VALORANTIGO , O.O, (SELECT NOW()), (SELECT CURRENT_USER()), 'D')
END
$

DELIMITER :

/* AUTORELACIONAMENTO */

-- SE EU TENHO UM CURSO QUE O PRE REQUISITO PARA FAZER ELE É OUTRO CURSO, CRIAMOS UMA TABELA REFERENCIANDO ELA MESMA PARA OUTRO ID QUE IRÁ RECEBER O ID DO CURSO QUE É PRE REQUISITO DESTE

CREATE DATABASE AULA;

CREATE TABLE CURSOS (
    IDCURSO INT PRIMARY KEY AUTO_INCREMENT
    NOME VARCHAR(30),
    HORAS INT,
    VALOR FLOAT(10,2)
    ID_PREREQUE INT
)

ALTER TABLE CURSOS
ADD CONSTRIANT FK_PREREQUE
FOREIGN KEY (ID_PREREQUE) REFERENCES CURSOS(IDCURSO)

INSERT INTO CURSOS VALUES(NULL, 'BD RELACIONAL', 20, 600.00, 2);
INSERT INTO CURSOS VALUES(NULL, 'LOGICA DE PROGRAMAÇÃO', 20, 600.00, NULL);
INSERT INTO CURSOS VALUES(NULL, 'C#', 20, 600.00, 2);
INSERT INTO CURSOS VALUES(NULL, 'JAVA', 20, 600.00, 2);
INSERT INTO CURSOS VALUES(NULL, 'JAVA SCRIPT', 20, 600.00, 2);
INSERT INTO CURSOS VALUES(NULL, 'CSS', 20, 600.00, 2);
INSERT INTO CURSOS VALUES(NULL, 'HTML', 20, 600.00, 2);

SELECT C1.NOME, C1.VALOR, C1.HORAS, IFNULL(C2.NOME, "SEM REQUISITO") AS REQUISITO
FROM CURSOS C1
LEFT JOIN CURSOS C2 ON C1.IDCURSO = C2.ID_PREREQUE

/* INTRODUÇÃO AOS CURSORES */

/* CURSOR É PARA SER USADO QUANDO UMA DETERMINADA OPERAÇÃO NÃO PODE SER REALIZADA COM SQL SIMPLES */

/* CURSOR VAI PARA MEMORIA RAM */

/* UM VETOR É UMA COLEÇÃO DE ELEMENTOS DO MESMO TIPO */

[AMARELO, AZUL, LARANJA, VERDE] - VETOR DE CORES
[KA, FIESTA, UNO, CIVIC] - VETOR DE CARROS

/* 
ELE ENTRA EM CADA REGISTRO E SALVA O O REGISTRO A EM UMA PARTE DO VETOR, O B EM OUTRA, O C EM OUTRA E ASSIM SUCESSIVAMENTE, E DEPOIS PERCORREE CADA UM DELES, ACESSANDO OS OS REGISTROS RELACIONADOS AO VETOR, O VETOR DE A CONTEM A POSIÇÃO DE CADA COLUNA DA LINHA A E ASSIM SUCESSIVAMENTE.

ELE É USADO QUANDO VOCÊ PRECISA INSERIR, ALTERAR, DELETAR DETERMINADOS REGISTROS QUE NA MÃO SERIA COMPLICADO.
 */

/* A 45 - CURSORES */

CREATE DATABASE CURSORES;
USE CURSORES;

CREATE TABLE VENDEDORES(
	IDVENDEDOR INT PRIMARY KEY AUTO_INCREMENT,
	NOME VARCHAR(50),
	JAN INT,
	FEV INT,
	MAR INT
);

INSERT INTO VENDEDORES VALUES(NULL,'MAFRA',32432,242334,574545);
INSERT INTO VENDEDORES VALUES(NULL,'CLARA',65465,65443,653454);
INSERT INTO VENDEDORES VALUES(NULL,'JOAO',12432,65356,8756);
INSERT INTO VENDEDORES VALUES(NULL,'LILIAN',4567,9676,8765);
INSERT INTO VENDEDORES VALUES(NULL,'ANTONIO',3467,68756,99765);
INSERT INTO VENDEDORES VALUES(NULL,'GLORIA',54786,76889,7098);

SELECT * FROM VENDEDORES;

SELECT NOME, (JAN+FEV+MAR) AS TOTAL FROM VENDEDORES;
SELECT NOME, (JAN+FEV+MAR) AS TOTAL, (JAN+FEV+MAR)/3 AS MEDIA FROM VENDEDORES;

CREATE TABLE VEND_TOTAL(
	NOME VARCHAR(50),
	JAN INT,
	FEV INT,
	MAR INT,
	TOTAL INT,
	MEDIA INT
);

DELIMITER $

CREATE PROCEDURE INSEREDADOS()
BEGIN
		DECLARE FIM INT DEFAULT 0;
		DECLARE VAR1, VAR2, VAR3, VTOTAL, VMEDIA INT;
		DECLARE VNOME VARCHAR(50);
		
		DECLARE REG CURSOR FOR(
			SELECT NOME, JAN, FEV, MAR FROM VENDEDORES
		);
		
		DECLARE CONTINUE HANDLER FOR NOT FOUND SET FIM = 1;
		
		OPEN REG;
		
		REPEAT
		
			FETCH REG INTO VNOME, VAR1, VAR2, VAR3;
			IF NOT FIM THEN
			
				SET VTOTAL = VAR1 + VAR2 + VAR3;
				SET VMEDIA = VTOTAL / 3;
				
				INSERT INTO VEND_TOTAL VALUES(VNOME,VAR1,VAR2,VAR3,VTOTAL,VMEDIA);
				
			END IF;
			
		UNTIL FIM END REPEAT;
		
		CLOSE REG;
END
$

SELECT * FROM VENDEDORES;
SELECT * FROM VEND_TOTAL;

DELIMITER ;

CALL INSEREDADOS();

/* 91. 2 e 3 Formas Normais! */

/* 

Primeira Forma Normal (1NF):
    A primeira forma normal define que cada valor em uma tabela deve ser atômico, ou seja, não deve ser divisível em partes menores. Isso significa que cada coluna de uma tabela deve conter apenas valores individuais, e não múltiplos valores combinados. Por exemplo, se tivermos uma tabela de clientes, cada coluna deve conter apenas um valor específico, como nome, endereço, telefone, e assim por diante. Se houver informações compostas, como vários números de telefone para um cliente, é necessário criar uma nova tabela relacionada para armazenar esses valores múltiplos.
    Além disso, cada tabela deve ter uma chave primária única. A chave primária é um atributo ou um conjunto de atributos que identifica de forma única cada registro na tabela. Ela garante que não haja duplicação de dados e permite a identificação precisa de registros individuais.

Segunda Forma Normal (2NF):
    A segunda forma normal estabelece que uma tabela deve estar na primeira forma normal e, além disso, todos os atributos não-chave devem depender totalmente da chave primária. Isso significa que cada coluna em uma tabela deve ser diretamente dependente da chave primária, e não de parte dela.
    Por exemplo, suponha que temos uma tabela de pedidos com as seguintes colunas: número do pedido, código do produto, nome do produto, quantidade do produto e preço unitário. A chave primária é o número do pedido. Nesse caso, o nome do produto, a quantidade e o preço unitário dependem diretamente da chave primária, pois cada um deles está associado a um número de pedido específico. No entanto, o código do produto não está diretamente relacionado à chave primária; ele está relacionado ao nome do produto. Para atender à segunda forma normal, devemos separar essas informações em duas tabelas diferentes: uma tabela de pedidos e outra tabela de produtos, onde o código do produto estará relacionado ao nome do produto.

Terceira Forma Normal (3NF):
    A terceira forma normal estabelece que uma tabela deve estar na segunda forma normal e, adicionalmente, não deve conter dependências transitivas. Isso significa que os atributos não-chave de uma tabela devem depender apenas da chave primária, e não de outros atributos não-chave.
    Por exemplo, considerando a tabela de pedidos mencionada anteriormente, suponha que além do nome do produto, também tenhamos o nome do fabricante na mesma tabela. Nesse caso, o nome do fabricante não depende diretamente da chave primária (número do pedido), mas sim do nome do produto. Para atender à terceira forma normal, devemos criar uma nova tabela de fabricantes, onde o nome do fabricante será a chave primária, e a tabela de pedidos fará referência ao fabricante por meio dessa chave primária, evitando assim a dependência transitiva.

    Essas três formas normais são utilizadas para garantir a organização eficiente dos dados em um banco de dados relacional, minimizando a redundância e assegurando a integridade dos dados.

 */

CREATE DATABASE CONSULTORIO;

CREATE TABLE PACIENTE(
	IDPACIENTE INT PRIMARY KEY AUTO_INCREMENT,
	NOME VARCHAR(30),
	SEXO CHAR(1),
	EMAIL VARCHAR(30),
	NASCIMENTO DATE
);

CREATE TABLE MEDICO(
	IDMEDICO INT PRIMARY KEY IDENTITY,
	NOME VARCHAR(30),
	SEXO CAHR(1),
	ESPECIALIDADE VARCHAR(30),
	FUNCIONARIO ENUM('S','N')
);

CREATE TABLE HOSPITAL(
	IDHOSPITAL INT PRIMARY KEY AUTO_INCREMENT,
	NOME VARCHAR(30),
	BAIRRO VARCHAR(30),
	CIDADE VARCHAR(30),
	ESTADO CHAR(2)
);

CREATE TABLE CONSULTA(
	IDCONSULTA INT PRIMARY KEY AUTO_INCREMENT,
	ID_PACIENTE INT,
	ID_MEDICO INT,
	ID_HOSPITAL INT,
	DATA DATETIME,
	DIAGNOSTICO VARCHAR(50)
);

CREATE TABLE INTERNACAO(
	IDINTERNACAO INT PRIMARY KEY AUTO_INCREMENT,
	ENTRADA DATETIME,
	QUARTO INT,
	SAIDA DATETIME,
	OBSERVACOES VARCHAR(50),
	ID_CONSULTA INT UNIQUE	
);  


/* CRIANDO CONSTRAINTS - CORREÇÃO COD DO OBJ (PK, FK)_TABELA PERTENCENTE_TABELA DE ONDE VEM */

ALTER TABLE CONSULTA
ADD CONSTRAINT FK_CONSULTA_PACIENTE
FOREIGN KEY ID_PACIENTE
REFERENCES PACIENTE(IDPACIENTE);

ALTER TABLE CONSULTA
ADD CONSTRAINT FK_CONSULTA_MEDICO
FOREIGN KEY ID_MEDICO
REFERENCES MEDICO(IDMEDICO);

ALTER TABLE CONSULTA
ADD CONSTRAINT FK_CONSULTA_HOSPITAL
FOREIGN KEY ID_HOSPITAL
REFERENCES HOSPUTAL(IDHOSPITAL);

ALTER TABLE INTERNACAO
ADD CONSTRAINT FK_INTERNACAO_CONSULTA
FOREIGN KEY ID_CONSULTA
REFERENCES CONSULTA(IDCONSULTA);

SHOW DATABASE;

USE INFORMATION_SCHEMA;

DESC TABLE_CONSTRAINTS;

SELECT * FROM TABLE_CONSTRAINTS;